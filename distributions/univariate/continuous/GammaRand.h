#ifndef GAMMARAND_H
#define GAMMARAND_H

#include "Distributions.h"
#include "univariate/ExponentialFamily.h"

/**
 * @brief The GammaDistribution class <BR>
 * Abstract class for Gamma distribution
 *
 * f(x | α, β) = β^α / Γ(α) * x^(α-1) * exp(-βx),
 * where Γ(α) denotes Gamma function
 *
 * Notation X ~ Γ(α, β)
 *
 * Related distributions: <BR>
 * σX ~ Γ(α, σβ) <BR>
 * If X ~ Γ(1, β), then X ~ Exp(β) <BR>
 * If X ~ Γ(0.5 * n, 0.5), then X ~ χ^2(n) <BR>
 * If X ~ Γ(k, β) for integer k, then X ~ Erlang(k, β)
 */
template <typename RealType = double>
class RANDLIBSHARED_EXPORT GammaDistribution
    : virtual public distributions::ContinuousDistribution<RealType> {
protected:
  double alpha = 1;               ///< shape α
  double beta = 1;                ///< rate β
  double theta = 1;               ///< scale θ = 1/β
  double lgammaAlpha = 0;         ///< log(Γ(α))
  double pdfCoef = 0;             ///< α * log(β) - log(Γ(α))
  double logAlpha = 0;            ///< log(α)
  double logBeta = 0;             ///< log(β)
  double digammaAlpha = -M_EULER; ///< ψ(α)

private:
  /// constants for faster sampling
  struct genCoef_t {
    double t, b;
  } genCoef = {0, 0};

protected:
  GammaDistribution(double shape, double rate);
  virtual ~GammaDistribution() {}

public:
  SUPPORT_TYPE SupportType() const override {
    return SUPPORT_TYPE::RIGHTSEMIFINITE_T;
  }
  RealType MinValue() const override { return 0; }
  RealType MaxValue() const override { return INFINITY; }

protected:
  /**
   * @fn SetParameters
   * @param shape α
   * @param rate β
   */
  void SetParameters(double shape, double rate);
  /**
   * @brief SetShape
   * @param shape α
   */
  void SetShape(double shape);

public:
  /**
   * @fn GetShape
   * @return α
   */
  inline double GetShape() const { return alpha; }
  /**
   * @fn GetScale
   * @return θ = 1/β
   */
  inline double GetScale() const { return theta; }
  /**
   * @fn GetRate
   * @return β
   */
  inline double GetRate() const { return beta; }
  /**
   * @fn GetLogGammaShape
   * @return log(Γ(α))
   */
  inline double GetLogGammaShape() const { return lgammaAlpha; }
  /**
   * @fn GetLogShape
   * @return log(α)
   */
  inline double GetLogShape() const { return logAlpha; }
  /**
   * @fn GetDigammaShape
   * @return ψ(α)
   */
  inline double GetDigammaShape() const { return digammaAlpha; }
  /**
   * @fn GetLogRate
   * @return log(β)
   */
  inline double GetLogRate() const { return logBeta; }

  double f(const RealType &x) const override;
  double logf(const RealType &x) const override;
  double F(const RealType &x) const override;
  double logF(const RealType &x) const;
  double S(const RealType &x) const override;
  double logS(const RealType &x) const;

private:
  enum GENERATOR_ID {
    INTEGER_SHAPE,        ///< Erlang distribution for α = 1, 2, 3
    ONE_AND_A_HALF_SHAPE, ///< α = 1.5
    SMALL_SHAPE,          ///< α < 0.34
    FISHMAN,              ///< 1 < α < 1.2
    MARSAGLIA_TSANG       ///< 0.34 < α < 1 or α >= 1.2
  };

  /**
   * @fn getIdOfUsedGenerator
   * @param shape α
   * @return id of used variate generator according to the shape
   */
  static GENERATOR_ID getIdOfUsedGenerator(double shape) {
    if (shape < 0.34)
      return SMALL_SHAPE;
    if (shape <= 3.0 && RandMath::areClose(shape, std::round(shape)))
      return INTEGER_SHAPE;
    if (RandMath::areClose(shape, 1.5))
      return ONE_AND_A_HALF_SHAPE;
    if (shape > 1.0 && shape < 1.2)
      return FISHMAN;
    return MARSAGLIA_TSANG;
  }

  /**
   * @fn variateThroughExponentialSum
   * @param shape α
   * @return gamma variate, generated by sum of exponentially distributed random
   * variables
   */
  static RealType variateThroughExponentialSum(int shape,
                                               RandGenerator &randGenerator);
  /**
   * @fn variateForShapeOneAndAHalf
   * @return gamma variate for α = 1.5
   */
  static RealType variateForShapeOneAndAHalf(RandGenerator &randGenerator);
  /**
   * @fn variateBest
   * @return gamma variate for small α, using Best algorithm
   */
  RealType variateBest(RandGenerator &randGenerator) const;
  /**
   * @fn variateAhrensDieter
   * @param shape α
   * @return gamma variate for small α, using Ahrens-Dieter algorithm (if we
   * have no pre-calculated values)
   */
  static RealType variateAhrensDieter(double shape,
                                      RandGenerator &randGenerator);
  /**
   * @fn variateFishman
   * @param shape α
   * @return gamma variate, using Fishman algorithm
   */
  static RealType variateFishman(double shape, RandGenerator &randGenerator);
  /**
   * @fn variateMarsagliaTsang
   * @param shape α
   * @return gamma variate, using Marsaglia-Tsang algorithm
   */
  static RealType variateMarsagliaTsang(double shape,
                                        RandGenerator &randGenerator);

public:
  /**
   * @fn StandardVariate
   * @param shape α
   * @return gamma variate with shape α and unity rate
   */
  static RealType
  StandardVariate(double shape,
                  RandGenerator &randGenerator =
                      ProbabilityDistribution<RealType>::staticRandGenerator);
  /**
   * @fn Variate
   * @param shape α
   * @param rate β
   * @return gamma variate with shape α and rate β
   */
  static RealType
  Variate(double shape, double rate,
          RandGenerator &randGenerator =
              ProbabilityDistribution<RealType>::staticRandGenerator);

  RealType Variate() const override;
  void Sample(std::vector<RealType> &outputData) const override;

  /**
   * @fn Mean
   * @return E[X]
   */
  long double Mean() const override;
  /**
   * @fn GeometricMean
   * @return E[ln(X)]
   */
  long double GeometricMean() const;
  /**
   * @fn Variance
   * @return Var(X)
   */
  long double Variance() const override;
  /**
   * @fn GeometricVariance
   * @return Var(ln(X))
   */
  long double GeometricVariance() const;
  RealType Mode() const override;
  RealType Median() const override;
  long double Skewness() const override;
  long double ExcessKurtosis() const override;

private:
  /// quantile auxiliary functions
  RealType initRootForSmallP(double r) const;
  RealType initRootForLargeP(double logQ) const;

  RealType initRootForSmallShape(double p) const
  {
      throw std::runtime_error("initRootForSmallShape - This function has not been implemented!");
  }

  RealType initRootForLargeShape(double p) const;
  RealType initRootForLargeShape1m(double p) const;
  RealType quantileInitialGuess(double p) const;
  RealType quantileInitialGuess1m(double p) const;

  /**
   * @fn df
   * derivative of probability density function
   * @param x
   * @return f'(x)
   */
  double df(RealType x) const;
  /**
   * @fn dfDivf
   * derivative of pdf, divided by pdf
   * @param x
   * @return f'(x) / f(x)
   */
  double dfDivf(RealType x) const;
  RealType quantileImpl(double p, RealType initValue) const override;
  RealType quantileImpl(double p) const override;
  RealType quantileImpl1m(double p, RealType initValue) const override;
  RealType quantileImpl1m(double p) const override;

  std::complex<double> CFImpl(double t) const override;
};

template <typename RealType> class RANDLIBSHARED_EXPORT GammaRand;

/**
 * @brief The FreeRateGammaDistribution class <BR>
 * Abstract class for Gamma distribution with arbitrary scale/rate
 */
template <typename RealType = double>
class RANDLIBSHARED_EXPORT FreeRateGammaDistribution
    : public GammaDistribution<RealType> {
protected:
  FreeRateGammaDistribution(double shape, double rate)
      : GammaDistribution<RealType>(shape, rate) {}

public:
  /**
   * @fn SetRate
   * set rate β
   * @param rate
   */
  void SetRate(double rate);

  /**
   * @fn SetScale
   * set scale θ = 1/β
   * @param scale
   */
  void SetScale(double scale);

  /**
   * @fn FitRate
   * set rate, estimated via maximum-likelihood method if unbiased = false,
   * otherwise set rate, returned by uniformly minimum variance unbiased
   * estimator
   * @param sample
   */
  void FitRate(const std::vector<RealType> &sample, bool unbiased = false);

  /**
   * @fn FitRateBayes
   * set rate, returned by bayesian estimation
   * @param sample
   * @param priorDistribution
   * @return posterior distribution
   */
  GammaRand<RealType>
  FitRateBayes(const std::vector<RealType> &sample,
               const GammaDistribution<RealType> &priorDistribution,
               bool MAP = false);
};

/**
 * @brief The GammaRand class <BR>
 * Gamma distribution
 */
template <typename RealType = double>
class RANDLIBSHARED_EXPORT GammaRand
    : public FreeRateGammaDistribution<RealType>,
      public ExponentialFamily<RealType, DoublePair> {
public:
  GammaRand(double shape = 1, double rate = 1)
      : FreeRateGammaDistribution<RealType>(shape, rate) {}
  String Name() const override;

  using GammaDistribution<RealType>::SetParameters;
  using GammaDistribution<RealType>::SetShape;

  /**
   * @fn FitShape
   * set shape, estimated via maximum-likelihood method
   * @param sample
   */
  void FitShape(const std::vector<RealType> &sample);

  /**
   * @fn Fit
   * set shape and rate, estimated via maximum-likelihood method
   * @param sample
   */
  void Fit(const std::vector<RealType> &sample);

  DoublePair SufficientStatistic(RealType x) const override;
  DoublePair SourceParameters() const override;
  DoublePair SourceToNatural(DoublePair sourceParameters) const override;
  double LogNormalizer(DoublePair parameters) const override;
  DoublePair LogNormalizerGradient(DoublePair parameters) const override;
  double CarrierMeasure(RealType) const override;
  double CrossEntropyAdjusted(DoublePair parameters) const override;
  double EntropyAdjusted() const override;
};

/**
 * @brief The ChiSquaredRand class <BR>
 * Chi-squared distribution
 *
 * Notation: X ~ χ^2(k)
 *
 * Related distributions: <BR>
 * X ~ Γ(0.5 * k, 0.5)
 */
template <typename RealType = double>
class RANDLIBSHARED_EXPORT ChiSquaredRand : public GammaDistribution<RealType> {
public:
  explicit ChiSquaredRand(size_t degree = 1)
      : GammaDistribution<RealType>(0.5 * degree, 0.5) {}
  String Name() const override;
  void SetDegree(size_t degree);
  inline size_t GetDegree() const { return static_cast<int>(2 * this->alpha); }
};

/**
 * @brief The ErlangRand class <BR>
 * Erlang distibution
 *
 * Notation: X ~ Erlang(k, β)
 *
 * Related distributions: <BR>
 * X ~ Y_1 + Y_2 + ... + Y_k, where Y_i ~ Exp(β) <BR>
 * X ~ Γ(k, β)
 */
template <typename RealType = double>
class RANDLIBSHARED_EXPORT ErlangRand
    : public FreeRateGammaDistribution<RealType> {
public:
  ErlangRand(int shape = 1, double rate = 1)
      : FreeRateGammaDistribution<RealType>(shape, rate) {}
  String Name() const override;
  void SetParameters(size_t shape, double rate);
  void SetShape(size_t shape);
};

#endif // GAMMARAND_H
